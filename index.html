<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>draw_objects</title>
</head>
<body>
    <h1>複数のオブジェクトを描く</h1>

    <canvas id="my-canvas" width="300" height="300"></canvas>

    <script>
        let canvas = document.getElementById('my-canvas');
        let width = canvas.width, height = canvas.height; // キャンバスのサイズ
        let ctx = canvas.getContext('2d', { alpha: false }); // 描画に使うコンテキスト
        let anime = null; // アニメーション
        let time = (new Date()).getTime(); // 時刻(ミリ秒単位)
        let objects = []; // オブジェクトの配列

        /**
         * @typedef {object} Position
         * @property {number} x - X座標
         * @property {number} y - Y座標
         */

        /**
         * @typedef {object} Velocity
         * @property {number} x - X方向の速度
         * @property {number} y - Y方向の速度
         */

        /**
         * @typedef {object} MovingObject
         * @property {Position} position - 初期位置
         * @property {Velocity} velocity - 初期速度
         */

        /**
         * オブジェクト群を作成する。
         * * @global {number} width - 描画領域の幅（初期位置と速度の範囲設定に使用）。
         * @global {number} height - 描画領域の高さ（初期位置と速度の範囲設定に使用）。
         */
        const createObjects = () => {
            let objects = [];
            // ランダムに位置と速度を決めて、オブジェクトを追加する
            for (let i = 0; i < 4; ++i) {
                // 位置
                const px = Math.random() * width;
                const py = Math.random() * height;
                // 速度
                const vx = (0.5 - Math.random()) * width;
                const vy = (0.5 - Math.random()) * height;
                // オブジェクトを追加
                const obj = {position: {x: px, y: py}, velocity: {x: vx, y: vy}};
                objects.push(obj);
            }
            return objects;
        };

        /**
         * オブジェクト群を現在の速度と経過時間に基づいて動かし、
         * 境界 (0, 0) から (width, height) までの範囲で壁との衝突判定と反射を行う。
         * * @param {MovingObject[]} objects - 動かす対象のオブジェクトの配列。各オブジェクトはpositionとvelocityプロパティを持つ。
         * @param {number} diff_time - 前回の更新からの経過時間 (ミリ秒)。
         * @param {number} width - 描画領域の幅 (グローバル変数として定義されていると想定)。
         * @param {number} height - 描画領域の高さ (グローバル変数として定義されていると想定)。
         */
        const moveObjects = (objects, diff_time) => {
            let diff_seconds = diff_time / 1000.0; // ミリ秒を秒単位にする

            for (let obj of objects) {
                obj.position.x += obj.velocity.x * diff_seconds;
                obj.position.y += obj.velocity.y * diff_seconds;
            }

            // カベに当たったら跳ね返る
            for (let obj of objects) {
                if (obj.position.x < 0) {
                    obj.position.x = 0;
                    obj.velocity.x = -obj.velocity.x;
                } else if (obj.position.x > width) {
                    obj.position.x = width;
                    obj.velocity.x = -obj.velocity.x;
                }
                if (obj.position.y < 0) {
                    obj.position.y = 0;
                    obj.velocity.y = -obj.velocity.y;
                } else if (obj.position.y > height) {
                    obj.position.y = height;
                    obj.velocity.y = -obj.velocity.y;
                }
            }
        };

        /**
         * オブジェクトの配列を受け取り、各位置にオブジェクトを描画する。
         * * @param {CanvasRenderingContext2D} ctx - 描画に使用するCanvas 2Dコンテキスト（グローバルに定義されていると想定）。
         * @param {MovingObject[]} objects - 描画するオブジェクトの配列。各オブジェクトはpositionプロパティを持つ。
         */
        const drawObjects = (ctx, objects) => {
            ctx.strokeStyle = "white";
            ctx.lineWidth = 3;
            ctx.fillStyle = "red";
            let radius = 10;
            for (let obj of objects) {
                // 丸を描画する。
                ctx.beginPath();
                ctx.arc(obj.position.x, obj.position.y, radius, 0, 2 * Math.PI, false);
                ctx.stroke();
                ctx.fill();
            }
        }

        // 描画する関数
        const render = () => {
            width = canvas.width;
            height = canvas.height;

            // 背景を黒で塗りつぶす
            ctx.clearRect(0, 0, width, height);

            // 経過時間を計算
            const new_time = (new Date()).getTime();
            const diff_time = new_time - time; // 経過時間
            time = new_time; // 時刻を更新

            // オブジェクト群を動かす
            moveObjects(objects, diff_time);

            // オブジェクト群を描く
            drawObjects(ctx, objects);

            // 次のアニメーションフレームを要求する
            if (anime)
                anime = window.requestAnimationFrame(render);
        };

        // オブジェクト配列の作成
        objects = createObjects();
        // アニメーションを開始する
        anime = window.requestAnimationFrame(render);
    </script>
</body>
</html>